#####################################################################################
# Project: MakeBind
# File: main.mk
# Description: Module loader for MakeBind
# Author: AntonioCS
# License: MIT License
#####################################################################################
ifndef __MB_CORE_MODULES_MANAGER_MK__
__MB_CORE_MODULES_MANAGER_MK__ := 1

mb_debug_modules ?= $(mb_debug)
mb_modules_db_all_modules :=# Empty
mb_modules_mod_info_file_name := mod_info.mk

### NOTE: Use mb_project_bindhub_modules_file for project modules file

define mb_modules_header
#####################################################################################
# Project: MakeBind
# File: mb_modules.mk
# Description: Module structure for MakeBind
# Author: AntonioCS
# License: MIT License
#####################################################################################
### NOTE: This file is autogenerated, do not edit it directly as it will be overwritten
### NOTE 2: Use mb/modules/list, mb/modules/add/<module>[/<module>], mb/modules/remove/<module>[/<module>] to manage your modules
### NOTE 3: If a module depends on another module, that module will automatically be added

endef

define mb_modules_mod_info_default_data
mb_module_name := $1
mb_module_version := 1.0.0
mb_module_description :=
mb_module_author :=
mb_module_license :=
mb_module_depends :=
endef


## Note: the $eval is in the middle of the lines so as not to cause a blank line in the output
define mb_modules_new_mod_start_data
#####################################################################################
# Project:
# File:
# Description:
# Author:
# License: MIT License$(strip $(eval $0_mod_name_caps := $(call mb_toupper, $1)))
#####################################################################################
ifndef __MB_MODULES_$($0_mod_name_caps)__
__MB_MODULES_$($0_mod_name_caps)__ := 1

## Your code here

endif # __MB_MODULES_$($0_mod_name_caps)__
endef

define mb_modules_build_mod_file
$(file > $(mb_project_bindhub_modules_file),$(mb_modules_header))
$(file >> $(mb_project_bindhub_modules_file),mb_project_modules_loaded :=$(if $(value mb_project_modules_loaded), $(mb_project_modules_loaded),## No modules added))
endef

## Create the mb_modules.mk if it doesn't exist
$(if $(wildcard $(mb_project_bindhub_modules_file)),,\
	$(call mb_modules_build_mod_file)\
)

## Find all info files
## $1: Path to search
define mb_modules_find_info
$(strip
$(eval $0_prm_path := $(strip $1))
$(shell find $($0_prm_path) -type f -name "$(mb_modules_mod_info_file_name)")
)
endef

## NOTE: May not work if there are spaces in the paths of the modules
## Called in main.mk
## Build the database of modules
define mb_modules_build_db
$(strip
	$(eval $0_all_modules_info_path := $(call mb_modules_find_info, $(mb_modules_path)/))
	$(if $(wildcard $(mb_project_bindhub_modules_path)/*),
		$(eval $0_all_modules_info_path += $(call mb_modules_find_info, $(mb_project_bindhub_modules_path)/))
	)
	$(foreach $0_module_info_path, $($0_all_modules_info_path),
		$(eval
			undefine mb_module_name
			undefine mb_module_version
			undefine mb_module_description
			undefine mb_module_author
			undefine mb_module_license
			undefine mb_module_depends
		)

		$(eval include $($0_module_info_path))

		$(eval
			mb_modules_db_all_modules += $(strip $(mb_module_name))
			mb_modules_db_version_$(mb_module_name) := $(strip $(mb_module_version))
			mb_modules_db_description_$(mb_module_name) := $(mb_module_description)
			mb_modules_db_depends_$(mb_module_name) := $(if $(value mb_module_depends),$(mb_module_depends))
			mb_modules_db_author_$(mb_module_name) := $(if $(value mb_module_author),$(mb_module_author))
			mb_modules_db_license_$(mb_module_name) := $(if $(value mb_module_license),$(mb_module_license))
			mb_modules_db_path_$(mb_module_name) := $(realpath $(dir $($0_module_info_path)))/$(mb_module_name).mk
        )
        $(if $(wildcard $(mb_modules_db_path_$(mb_module_name))),,
			$(error ERROR: Module $(mb_module_name) is missing the implementation file $(mb_modules_db_path_$(mb_module_name)))
		)
	)
)
endef


define mb_load_modules
$(strip
	$(if $(value mb_project_modules), $(call mb_printf_warn, mb_project_modules is now deprecated$(mb_comma) please remove it and use mb/modules/add to add your modules))
	$(call mb_debug_print, Starting modules loading,$(mb_debug_modules))
	$(eval -include $(mb_project_bindhub_modules_file))
	$(foreach $0_mod,$(mb_project_modules_loaded),
		$(call mb_debug_print, Loading module: $($0_mod),$(mb_debug_modules))
		$(if $(call mb_module_is_valid_mod,$($0_mod)),
			$(call mb_debug_print, $($0_mod) path $(mb_modules_db_path_$($0_mod)), $(mb_debug_modules))
			$(eval include $(mb_modules_db_path_$($0_mod)))
		,
			$(call mb_printf_error, Module $($0_mod) is invalid)
		)
	)
)
endef

## Check if given module name is valid
## $1 string Module name
define mb_module_is_valid_mod
$(strip
	$(eval $0_prm_mod_name := $(strip $1))
	$(if $(filter $($0_prm_mod_name),$(mb_modules_db_all_modules)),
		$(mb_true),
		$(mb_false)
	)
)
endef


## Check if module is added to the project
## $1 string Module name
define mb_module_is_mod_added
$(strip
	$(eval $0_prm_mod_name := $(strip $1))
	$(if $(filter $($0_prm_mod_name),$(mb_project_modules_loaded)),
		$(mb_true),
		$(mb_false)
	)
)
endef

## Add module to the project
## $1 string Module name
## $2 bool Silence dependency check warning if already loaded
define mb_module_add
$(strip
	$(eval 1 := $(strip $1))
	$(eval $0_prm_mod_name_$1 := $1)
	$(eval $0_prm_silence_dependency_warn_$1 := $(if $(value 2),$(mb_true)))
	$(if $(call mb_module_is_valid_mod,$($0_prm_mod_name_$1)),
	,
		$(call mb_printf_error, Module $($0_prm_mod_name_$1) not found)
	)
	$(if $(call mb_module_is_mod_added,$($0_prm_mod_name_$1)),
		$(if $($0_prm_silence_dependency_warn_$1),
		,
			$(call mb_printf_warn, Module $($0_prm_mod_name_$1) already added to project)
		)
	,
		$(eval mb_project_modules_loaded += $($0_prm_mod_name_$1))
		$(if $(mb_modules_db_depends_$($0_prm_mod_name_$1)),
			$(call mb_printf_info, Module $($0_prm_mod_name_$1) depends on $(mb_modules_db_depends_$($0_prm_mod_name_$1)))
			$(call mb_module_add,$(mb_modules_db_depends_$($0_prm_mod_name_$1)),$(mb_true))
		)
		$(call mb_printf_info, Module $($0_prm_mod_name_$1) added to project)
		$(call mb_modules_build_mod_file)
	)
)
endef


## Remove a module from the project
## $1 string Module name
## NOTE: To prevent recursion issues, I have to use the name of the module given as a variable name suffix
define mb_module_remove
$(strip
	$(eval 1 := $(strip $1))
	$(eval $0_prm_mod_name_$1 := $1)
	$(if $(call mb_module_is_mod_added,$($0_prm_mod_name_$1)),
		$(eval mb_project_modules_loaded := $(filter-out $($0_prm_mod_name_$1),$(mb_project_modules_loaded)))
		$(call mb_printf_info, Module $($0_prm_mod_name_$1) removed from project)
		$(call mb_modules_build_mod_file)
		$(eval $0_loaded_modules_$1 := $(mb_project_modules_loaded))
		$(foreach $0_mod_$1,$($0_loaded_modules_$1),
			$(call mb_printf_info, Checking if module $($0_mod_$1) depends on $($0_prm_mod_name_$1))
			$(if $(and $(mb_modules_db_depends_$($0_mod_$1)),$(filter $($0_prm_mod_name_$1),$(mb_modules_db_depends_$($0_mod_$1)))),
				$(call mb_printf_info, Module $($0_mod_$1) depends on $($0_prm_mod_name_$1)$(mb_comma) removing it)
				$(call mb_module_remove,$($0_mod_$1))
			)
		)
	,
		$(call mb_printf_warn, Module $($0_prm_mod_name_$1) not found in project)
	)
)
endef


mb/modules/list: ## List all modules available
	$(info Modules available:)
	$(foreach $@_mod,$(mb_modules_db_all_modules),
		$(eval $@_is_loaded := $(if $(call mb_module_is_mod_added,$($@_mod)),(in project) ,$(mb_empty)))
		$(info - $($@_mod) ($(mb_modules_db_version_$($@_mod))): $($@_is_loaded)$(mb_modules_db_description_$($@_mod)) $(if $(mb_modules_db_depends_$($@_mod)),(Depends on: $(mb_modules_db_depends_$($@_mod))))) \
	)

mb/modules/add/%: ## Add one ore more modules. Pass <mod>
	$(eval $@_mods_to_add = $(subst /, ,$(strip $*)))
	$(foreach $@_mod_name,$($@_mods_to_add),\
		$(call mb_module_add,$($@_mod_name))\
	)


mb/modules/remove/%: ## Remove a module. Pass <mod>
	$(eval $@_mods_to_remove = $(subst /, ,$(strip $*)))
	$(foreach $@_mod_name,$($@_mods_to_remove),\
		$(call mb_module_remove,$($@_mod_name))\
	)


mb/modules/create/%: ## Create a new module. Pass <module_name>
	$(eval $@_mod_name = $*)
	$(eval $@_mod_folder = $(mb_project_bindhub_modules_path)/$($@_mod_name))
	$(eval $@_mod_filename := $($@_mod_name).mk)
	$(if $(call mb_exists,$($@_mod_folder)/$($@_mod_filename)),\
		$(call mb_printf_error, Module $($@_mod_name) already exists)\
	)
	$(shell mkdir -p $($@_mod_folder))
	$(file > $($@_mod_folder)/$(mb_modules_mod_info_file_name),$(call mb_modules_mod_info_default_data,$($@_mod_name)))
	$(file > $($@_mod_folder)/$($@_mod_filename),$(call mb_modules_new_mod_start_data,$($@_mod_name)))


endif # __MB_CORE_MODULES_MANAGER_MK__
